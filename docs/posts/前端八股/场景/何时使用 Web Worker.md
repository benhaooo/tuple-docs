# 何时使用 Web Worker：核心原则与应用场景

## 一、核心使用场景

**Web Worker** 主要用于处理那些计算量大、耗时长的任务，避免阻塞浏览器主线程，从而提升用户体验。

> 核心思想：将 **CPU 密集型** 任务从主线程剥离，放入 Worker 线程执行。

### 典型应用

1.  **大文件上传**

      * **主要瓶颈**：并非文件分片（slicing）本身，而是对每个分片进行 **哈希计算**（如 `MD5`）。这个计算过程是纯粹的运算，属于 CPU 密集型任务。
      * **解决方案**：在主线程中对文件进行快速分片，然后将这些分片（chunks）分配给多个 Web Worker，并行计算它们的哈希值。

2.  **大量的图表计算**

      * 当需要动态生成或处理大量图表数据时，如果其中涉及复杂的数学运算和数据转换，可以利用 Web Worker 在后台处理，主线程仅负责最终的渲染。

## 二、使用 Web Worker 的两大前提条件

只有同时满足以下两个条件，使用 Web Worker 才是合理且高效的。

### 条件一：任务是 CPU 密集型 (CPU-Intensive)

必须正确区分 **CPU 密集型** 和 **I/O 密集型** 任务。

| 类型 | 定义 | 示例 | 推荐方案 |
| :--- | :--- | :--- | :--- |
| **CPU 密集型** | 任务需要消耗大量的 CPU 资源进行运算。 | \<ul\>\<li\>哈希计算 (`MD5`, `SHA`)\</li\>\<li\>复杂的数学运算\</li\>\<li\>图片/视频处理\</li\>\<li\>大量数据的排序和转换\</li\>\</ul\> | **多线程 (Web Worker)** |
| **I/O 密集型** | 任务涉及大量的输入/输出操作，CPU 多数时间在等待。 | \<ul\>\<li\>网络请求 (`fetch`, `ajax`)\</li\>\<li\>读写本地磁盘文件\</li\>\<li\>数据库操作\</li\>\</ul\> | **异步 (Asynchronous)** |

**关键辨析**：

  * **网络请求** 属于 I/O 密集型任务，其瓶颈在于网络延迟和数据传输，而非 CPU 计算。因此，它不适合使用 Web Worker，而应采用 `async/await` 或 `Promise` 等异步方案。
  * Node.js 的成功正是因为它采用事件循环和异步 I/O 模型来高效处理海量 I/O 密集型请求，避免了传统多线程模型中线程创建和上下文切换的巨大开销。

### 条件二：任务可以被独立拆分 (Can be split independently)

要使用多线程，任务本身必须能够被分解成多个互不依赖的子任务。

  * **可拆分任务 (✅)**：

      * **场景**：计算一个超大数组中所有元素的总和。
      * **方法**：可以将数组切分成 N 个小段，每个 Worker 负责计算一小段的和，最后主线程将所有 Worker 的结果相加。每个子任务（计算一小段的和）之间没有依赖关系。
      * **代码思路**：
        ```javascript
        // 伪代码
        const largeArray = [/* 1亿个数字 */];
        const chunkSize = 1000000;

        // 主线程：任务拆分
        for (let i = 0; i < largeArray.length; i += chunkSize) {
            const chunk = largeArray.slice(i, i + chunkSize);
            const worker = new Worker('sum_worker.js');
            worker.postMessage(chunk);
            // ... 监听 worker 返回结果并汇总
        }
        ```

  * **不可拆分任务 (❌)**：

      * **场景**：一个任务的下一步计算依赖于上一步的输出结果。
      * **例子**：浏览器的渲染管线（Render Pipeline），每一步（如样式计算、布局、绘制）都严格依赖前一步的结果。
      * **结论**：这种具有强前后依赖关系的任务链条无法并行化，不能使用 Web Worker 加速。

## 三、总结：大文件上传实践

大文件上传是前端应用 Web Worker 最经典、最常见的场景。

1.  **满足 CPU 密集型**：对分片进行哈希校验是核心耗时点。
2.  **满足可拆分**：计算第 100 个分片的哈希值与计算第 500 个分片的哈希值互不干扰，可以完美并行。

> **注意**：一个完整的大文件上传方案远比这复杂，它涉及前后端协同。
>
>   * **分片策略**：如何高效分片。
>   * **上传协议**：客户端和服务器需要约定一套完整的文件上传、校验、合并协议。
>   * **并发控制**：如何管理 Worker 的数量和请求的并发。
>   * **错误处理**：断点续传、失败重试等。
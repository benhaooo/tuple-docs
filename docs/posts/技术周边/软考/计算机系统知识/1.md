# 第一章 计算机系统知识

## 主要内容概览

1.  **计算机系统基础知识**
    -   **硬件基本组成**: 冯诺依曼计算机五大部件 (运算器、控制器、存储器、输入/输出设备)。
    -   **中央处理单元 (CPU)**: 运算器、控制器、寄存器等的功能与组成。
    -   **数据的表示**: 定点数、浮点数、原码、反码、补码、移码以及校验码 (奇偶校验、海明码)。
2.  **计算机体系结构**
    -   **发展**: 了解即可。
    -   **存储系统**: 寄存器、Cache、主存、外存等工作原理。
    -   **输入/输出系统**: 程序查询、中断、DMA、通道四种I/O技术的原理、特点及适用场合。
    -   **总线结构**: 总线分类及常见总线。
3.  **安全性、可靠性与系统性能评测**
    -   **计算机安全**: 概述、加密技术 (对称/非对称)、认证技术。
    -   **计算机可靠性**: 串联、并联系统的可靠性计算。
    -   **计算机性能评价**: 常用性能指标和评测方法。

---

## 1.1 计算机系统的基础知识

### 1.1.1 计算机系统的硬件基本组成

基于**冯诺依曼 (Von Neumann)** 结构，计算机硬件由五大部件组成：

1.  **运算器 (Arithmetic Unit)**: 执行算术和逻辑运算。
2.  **控制器 (Control Unit)**: 指挥和控制计算机各部件协调工作。
    -   `运算器 + 控制器` + 其他部件 (寄存器、内部总线) = **中央处理单元 (CPU)**。
3.  **存储器 (Memory)**: 记忆设备，用于存放程序和数据。
    -   **内部存储器 (内存)**: 速度快，容量小，临时存放数据。
    -   **外部存储器 (硬盘)**: 速度慢，容量大，长期保存数据。
4.  **输入设备 (Input Device)**: 输入原始数据和指令 (如：键盘、鼠标)。
5.  **输出设备 (Output Device)**: 输出处理结果 (如：显示器、打印机)。
    -   `输入设备 + 输出设备` = **外部设备 (外设)**。

### 1.1.2 中央处理单元 (CPU)

CPU是计算机的大脑，主要由**运算器**、**控制器**、**寄存器组**和**内部总线**组成。

#### 1. 运算器 (Arithmetic Unit)

-   **功能**: 执行**算术运算** (加、减、乘、除) 和**逻辑运算** (与、或、非、异或)。
-   **核心组件**:
    -   **算术逻辑单元 (ALU)**: **核心部件**，真正执行算术和逻辑运算。
    -   **累加寄存器 (AC)**: 为 ALU 提供工作区，暂存运算结果。
    -   **数据缓冲寄存器 (DR)**: 读写内存时，暂存指令或数据。
    -   **状态条件寄存器 (PSW)**: 保存运算产生的状态标志 (如：进位、溢出) 和控制标志。

#### 2. 控制器 (Control Unit)

-   **功能**: 负责协调和指挥整个计算机系统的操作。
-   **核心组件**:
    -   **指令 (Instruction)**: 由`操作码`和`地址码`组成。
        -   **操作码**: 指示指令的功能 (如：加法、移位)。
        -   **地址码**: 指示操作数或数据的地址。
    -   **指令寄存器 (IR)**: 存放**当前正在执行或即将执行**的指令。
    -   **程序计数器 (PC)**:
        1.  存放**下一条要执行指令的地址**。
        2.  具有**自动加1** (一个指令长度) 的功能，以指向下一条指令。
    -   **地址寄存器 (AR)**: 存放 CPU **当前正在访问的内存单元的地址**。
    -   **指令译码器 (ID)**: 对指令的操作码进行分析和解释，翻译其功能。

#### 3. CPU 寄存器组

-   **专用寄存器**: 上述运算器和控制器中的寄存器 (AC, DR, PSW, IR, PC, AR)。
-   **通用寄存器**: 为 ALU 提供工作区，可由程序员决定其用途。
-   **程序员可见性**:
    -   **可见**: 通用寄存器组, PSW, PC, AC。
    -   **不可见**: IR, DR, AR。

#### 4. 简易 CPU 模型

CPU 的工作流程是一个不断**取指令、执行指令**的循环。
1.  **取指**: PC 提供下一条指令的地址。
2.  **传送**: 该地址送至 AR，内存根据 AR 的地址找到指令，通过数据总线送入 DR，再送至 IR。
3.  **PC更新**: PC 自动加1，指向下一条指令。
4.  **译码**: IR 中的指令送至 ID 进行译码。
5.  **执行**: 操作控制器根据译码结果发出控制信号，指挥 ALU 等部件执行操作。如果需要操作数，则根据地址码从内存中获取数据。

---
**练习题**

1.  **CPU (中央处理单元) 的基本组成部件不包括？**
    -   A. 算术逻辑运算单元 (ALU)
    -   B. 系统总线
    -   C. 控制单元 (CU)
    -   D. 寄存器组
    > **解析**: 系统总线是连接 CPU、内存和 I/O 设备的公共通道，位于 CPU **外部**。CPU 内部的叫**内部总线**。因此 B 不属于 CPU 的组成部件。

2.  **在 CPU 中，用什么给出将要执行的下一条指令在内存中的地址？**
    -   A. 程序计数器 (PC)
    -   B. 指令寄存器 (IR)
    -   C. 主存地址寄存器 (AR)
    -   D. 状态条件寄存器 (PSW)
    > **解析**: PC 的核心功能就是存放下一条指令的地址。

---

### 1.1.3 数据的表示

#### 1. 进制转换 (复习)

-   **二进制 (B)**: 由 `0` 和 `1` 组成，逢二进一。
-   **八进制 (Q/O)**: 由 `0-7` 组成，逢八进一。
-   **十进制 (D)**: 由 `0-9` 组成，逢十进一。
-   **十六进制 (H)**: 由 `0-9` 和 `A-F` (表示10-15) 组成，逢十六进一。

**示例**: 十进制数 `136` 的构成为：
`1 * 10^2 + 3 * 10^1 + 6 * 10^0`

二进制数 `10111B` 转为十进制：
`1*2^4 + 0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = 16 + 0 + 4 + 2 + 1 = 23D`

#### 2. 单位换算 (复习)

-   **位 (bit, b)**: 二进制中的一位。
-   **字节 (Byte, B)**: `1 B = 8 bit`
-   **千字节 (KB)**: `1 KB = 1024 B = 2^10 B`
-   **兆字节 (MB)**: `1 MB = 1024 KB = 2^10 KB`
-   **吉字节 (GB)**: `1 GB = 1024 MB = 2^10 MB`
-   **太字节 (TB)**: `1 TB = 1024 GB = 2^10 GB`

#### 3. 定点数 (Fixed-Point Numbers)

小数点位置固定的数，用于表示纯整数或纯小数。计算机中存储数据采用**补码**形式。

-   **基本格式**:
    ```
    符号位 | 数值位
    ```
    -   **符号位**: 最高位。`0` 表示正数，`1` 表示负数。

| 码制 | 定义 | 快速求法 |
| :--- | :--- | :--- |
| **原码** | 最高位为符号位，其余位为数值的绝对值的二进制。 | 直接转换。 |
| **反码** | **正数**: 与原码相同。<br>**负数**: 原码的符号位不变，数值位按位取反 (`0`变`1`, `1`变`0`)。 | |
| **补码** | **正数**: 与原码相同。<br>**负数**: 其反码的末位加1。 | **【重点】** 从原码的**最低位**向高位找，找到**第一个1**及其之前的所有位**保持不变**，这个1之后的所有数值位**按位取反**，符号位不变。 |
| **移码** | 补码的符号位按位取反。主要用于浮点数的阶码表示。 | |

**示例**: 机器字长为8位，求 `-19` 的四种码。

1.  **求 +19 的二进制**: `19 = 16 + 2 + 1 = 10011`
2.  **求 -19 的原码**:
    -   符号位为 `1`。
    -   数值位为 `0010011` (补足8位)。
    -   结果: `10010011`
3.  **求 -19 的反码**:
    -   符号位 `1` 不变。
    -   数值位取反: `0010011` -> `1101100`。
    -   结果: `11101100`。
4.  **求 -19 的补码**:
    -   方法一: 反码 `11101100` 末位加1。
    -   结果: `11101101`。
    -   方法二(快速法): 原码`10010011`，从右到左找到第一个`1` (即最低位)，该`1`及其右边不变，左边的数值位取反。
    -   结果: `11101101`。
5.  **求 -19 的移码**:
    -   补码 `11101101` 的符号位取反。
    -   结果: `01101101`。

**为什么计算机使用补码？**
-   `0` 的表示唯一。
-   可以将**减法运算转换为加法运算**，简化硬件电路设计。
-   符号位可以和数值位一样参与运算。

#### 4. 浮点数 (Floating-Point Numbers)

小数点位置不固定的数，用于表示更大范围和更高精度的数。

-   **一般形式**: `N = R^E × M`
    -   `R`: 基数 (Radix)，二进制中为 `2`。
    -   `E`: 阶码 (Exponent)，决定数值**范围**。
    -   `M`: 尾数 (Mantissa)，决定数值**精度**。
-   **IEEE 754 标准 (32位单精度)**:
    -   **结构**:
        ```
        S (1位) | E (8位)  | M (23位)
        符号位   |  阶码     |  尾数
        ```
    -   **符号位 (S)**: `0`表示正，`1`表示负。
    -   **阶码 (E)**: 使用**移码**表示。`阶码真值 = E - 127`。
    -   **尾数 (M)**: 规格化后，隐藏整数部分的 `1`，只存储小数部分。

**示例**: 将十进制 `176.0625` 表示为32位IEEE 754格式。
1.  **转二进制**:
    -   整数部分: `176 = 128 + 32 + 16 = 10110000`
    -   小数部分: `0.0625 × 2 = 0.125` (取0), `0.125 × 2 = 0.25` (取0), `0.25 × 2 = 0.5` (取0), `0.5 × 2 = 1.0` (取1) -> `.0001`
    -   结果: `10110000.0001`
2.  **规格化**:
    -   小数点左移7位，得到 `1.01100000001`。
    -   形式: `1.01100000001 × 2^7`
3.  **确定三要素**:
    -   **S**: 正数，所以 `S = 0`。
    -   **E**: 阶码真值为`7`。`E = 7 + 127 = 134`。`134`的二进制为 `10000110`。
    -   **M**: 隐藏整数部分的`1`后，取小数部分 `01100000001`，用0补足23位。
4.  **组合**:
    `0 | 10000110 | 01100000001000000000000`

#### 5. 浮点数的加减运算

1.  **对阶**: 小阶向大阶看齐，将阶码较小的数的尾数右移，使其阶码与较大的数相同。
2.  **尾数求和**: 将对阶后的两个尾数相加/减。
3.  **规格化**: 将结果调整为 `1.M` 的形式。
4.  **舍入**: 如果规格化导致尾数超出位数，进行舍入操作。
5.  **判溢出**: 判断阶码是否超出表示范围。

#### 6. 校验码 (Checksum)

用于检测数据在传输或存储过程中是否出错。

-   **奇偶校验码 (Parity Check)**
    -   在数据位后增加一位校验位。
    -   **奇校验**: 保证整个码字（数据位+校验位）中 `1` 的个数为奇数。
    -   **偶校验**: 保证整个码字中 `1` 的个数为偶数。
    -   **缺点**: 只能检测出**奇数位**错误，无法纠错。

-   **海明码 (Hamming Code)**
    -   一种多重奇偶校验码，具有**检错**和**纠错**能力 (通常能纠正一位错误)。
    -   **关系式**: 设数据位为 `n` 位，校验位为 `k` 位，则：
        `n + k + 1 ≤ 2^k`

-   **循环冗余校验码 (CRC)**
    -   利用多项式除法原理进行校验，检错能力强。
    -   广泛应用于数据链路层。

---
**练习题**

1.  **假设信息位为8位，用海明码来发现并纠正一位出错的情况，则校验位的位数至少是多少？**
    > **解析**:
    > -   数据位 n = 8。
    > -   代入公式 `n + k + 1 ≤ 2^k`，即 `8 + k + 1 ≤ 2^k` -> `9 + k ≤ 2^k`。
    > -   逐个尝试 k 的值：
    >   -   k=1: `10 ≤ 2` (False)
    >   -   k=2: `11 ≤ 4` (False)
    >   -   k=3: `12 ≤ 8` (False)
    >   -   k=4: `13 ≤ 16` (True)
    > -   所以 k 至少为 **4**。